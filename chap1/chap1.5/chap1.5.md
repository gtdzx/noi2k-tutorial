Chap 1.5 循环控制
==================
作者：郭炜，摘自其编著《新标准C++程序设计》
时间：2015-07-12  


循环控制结构
-----------------
我们常常需要在程序里成千上万次地执行同样的操作。比如，要求写一个程序，依次输出1到10000的所有整数。我们不可能用写10000条cout语句的笨办法来实现，合理的一种做法是让一个变量的值初始值等于0，然后反复执行以下操作10000次：

```
该变量值增加1 
输出该变量的值
```

程序设计语言里都会有将某些语句重复执行若干次的机制，这个机制就叫循环结构。




### 用 for 语句实现循环结构

C++提供了for语句，用来重复执行相同的语句若干次，执行的次数一般是某个常量，或某个变量的值。for语句的基本格式如下：

```cpp
for( 表达式1 ;表达式2;表达式3)  {
	语句组
}
```

如果语句组只由一条语句构成，那么也可以去掉“{}”。
通常，在需要将一些语句循环执行若干次的情况下，使用for语句比较方便。
for语句的执行过程如下：

```
1)	计算 “表达式1”。
2)	计算 “表达式2”，如果其值为true，则执行“{ }”中的语句组，然后转到3)；如果为false,则不再执行“{}”中的语句组，for语句结束，转到5)。
3)	计算“表达式3”。
4)	转到2)。
5)	从for语句后面继续往下执行程序。
```

来看一个for语句的例子：

```cpp
int i;                                                    
for( i = 0;i < 26; ++i ) {
		cout << char('a'+i ) << endl;
}
```
上面这个for语句，由于循环里只有一条语句，“{}”其实也可以去掉。这条for语句的作用是依次输出26个小写字母。由于字符'a'  ～ 'z'的ASCII码是连续的，所以'a'+i就是第i个字母的ASCII码（'a'算第0个字母，'z'算第25个），将'a'+i 转换成char类型输出，就会输出第i个字母。上述for语句，每次循环都输出第i个字母，然后i的值增加1。只要i的值还小于26，就依然会执行循环。i的值在循环开始执行前被置成了0，因此循环一共会执行26次。

上面语句中的i用来控制循环执行的次数，称为循环控制变量。一段程序里经常会用到多个for循环。大家一般习惯将循环控制变量定义为i或j，写一个for循环之前，就要想想是不是要定义循环控制变量i,j， 如果前面已经定义过了，就不能再定义，否则编译的时候会引起变量重复定义的错误 --- 老要想这件事，比较麻烦。因此C++允许写for语句的时候，在“表达式1”处定义一个或多个变量，而且这些变量的作用域仅限于for语句之内。这样，就可以在总是在“表达式1”处定义循环控制变量，不用管前面是不是定义过了。于是，先输出26个小写字母，然后再间隔着输出13个大写字母的程序，可以如下编写：

```cpp
for( int i = 0;i < 26; ++i ) 
	cout << char('a'+i ) << endl;
	for( int i = 0;i < 26; i+=2 ) //循环控制变量并非每次只能加1
		cout << char('A'+i ) << endl;

```

不用担心两个i会导致重复定义的错误，因为它们各自的作用域（就是能起作用的范围）都仅限于它所处的for语句内。

对循环控制变量i进行加1 的时候，许多程序员以及教科书都会写“i++”，而不是 “++i”。表面上看没有区别，实际上“++i”的写法是一种更好的习惯，显得更加专业和规范，因为++i比i++执行速度更快。尤其在学了“运算符重载”和“标准模板库STL”后就更能体会这一点了

for循环结构里的“表达式1”和“表达式3”都可以是用逗号连接的若干个表达式。比如下面的程序片段：

```cpp
for( int i= 15, j = 0; i > j; i-=2 ,j+= 3)
	cout << i << "," j << endl;
```
输出结果是：
```
15,0
13,3
11,6
```
例题: 请写一个程序，输入一个正整数n，输出它的所有因子。

此程序的基本思路就是枚举，对于不超过n的每个正整数，都判断一下是否是n的因子，如果是，则输出。

```cpp
1.	#include <iostream>
2.	using namespace std;
3.	int main()
4.	{
5.		int n;
6.		cin >> n;
7.		for( int i = 1;i <= n; ++i) 
8.	 		if( n % i == 0 )
9.	 			cout << i << endl;
10.	  	return 0;
11.	}
```

上面的for循环里只有一条if语句，if语句里也只有一条输出语句，所以就都用不着写“{}”了。

该程序枚举的顺序是从小到大。如果要求以从大到小的顺序输出所有因子，那么枚举的顺序也应该从大到小，程序中的for循环可以如下改写：

```cpp
for( int i = n;i >= 1; --i ) 
	if( n % i == 0 )
		 cout << i << endl; 

```
在一个for循环里还可以执行另一个for循环。例如下面的两重循环：

```cpp
	for(int i = 0;i < n; ++ i) {
		……
		for(int j = 0; j < m; ++j  ) {
			……
		}
		……
	}
```


假设n和m的值在执行过程中不发生变化，那么外重循环每执行1次，内重循环就执行m次，内重循环的执行次数一共是n×m次。在上面的程序片段里，内重循环每次开始的时候，都会先将j的值初始化为0。


例题: 给定正整数n和m,在1至n这n个数中，取出两个不同的数，使得其和是m的因子，问有多少种不同的取法。

解题的思路就是枚举所有两个数的不同取法，看其和是否为m的因子，如果是，就将总取法数目加1。枚举取两个数的不同取法，可以用两重for循环实现。程序如下：

```cpp
1.	#include <iostream>
2.	using namespace std;
3.	int main()
4.	{
5.		int n,m;
6.		int total = 0;  //取法总数
7.		cin >> n >> m;
8.		for( int i = 1; i < n; ++i )  //取第一个数，共n-1种取法
9.			for( int j = i + 1; j <= n; ++j ) //第二个数要比第一个数大,以免取法重复
10.				if( m % (i + j) == 0 )
11.			  		  ++ total ;
12.	     cout << total;  
13.	  	return 0;
14.	}
```


另外，for 语句括号里面的“表达式1”，“表达式2”，“表达式3”任何一个都可以不写，甚至可以全都不写，但是“;”必须保留。如：

```cpp
for(  ; i < 100; ++ i )  
	cout << i ;
```

假设i在for语句之前已经有合理的值了，那么上面的for语句里就没必要写“表达式1”了。

如果不写“表达式2”，就意味着永远执行循环（也叫死循环）。比如:

```cpp
for( ; ; ) 
	cout << “hello” <<endl;
```

上面语句就会不停输出”hello”。

在for( ; ; ) 这样的循环里可以通过“break”语句跳出循环，后文会提到。


用 while 语句实现循环结构
--------------------------

有的时候要执行的循环，该什么时候结束和循环已经执行了多少次没有关系，而是当且仅当在满足某个条件后循环才终止，在这种情况下，就应该使用while语句来实现循环。
C++中while语句的格式是：

while( 表达式) {
		语句组
}
while语句的执行过程是：

1）	判断“表达式”是否为真，如果不为真，则转4)
2)	执行“语句组”
3)	转1)
4)	while语句结束，从while语句后面的语句继续执行。

总之，当且仅当“表达式”的值为真，才会执行循环里面的语句组；如果“表达式”一开始的值就是假的，那么，整个循环就一次也不会执行。

如果“语句组”里只有一条语句，也可以省略“{}”。

如果要写一个死循环，可以写：

```cpp
while(true) {
	……
}
```


中间同样可以使用“break”语句跳出循环。


例题:用牛顿迭代法求输入的数的平方根。牛顿迭代法求平方根的基本思想是：欲求a的平方根，首先猜测一个值x1=a/2（也可以是随便什么其他值）作为其平方根，然后根据下面的迭代公式算出x2，再将x2代入公式右边算出x3……直到连续两次算出的xn和xn+1的差的绝对值小于某个值ε，即认为找到了足够精确的平方根。这个ε值取得越小，计算出来的平方根就越精确。

迭代公式： x[n+1] = (x[n] + a / x[n]) / 2 


解题程序：

```cpp
1.	#include <iostream>
2.	using namespace std;
3.	const double EPS = 0.001; //用以控制计算精度
4.	int main()
5.	{
6.		double a;
7.		cin >> a ;  //输入a,要求a的平方根
8.		if( a >= 0) {
9.			double x = a/2,lastX = x + 1 + EPS;  //确保能够进行至少一次迭代
10.			while( x - lastX > EPS || lastX - x > EPS){ //只要精度未达要求，就继续迭代
11.				lastX = x;
12.				x = (x + a/x)/2;
13.			}
14.			cout << x;
15.		}
16.		else 
17.			cout << "It can't be nagitive.";
18.		return 0;
19.	}
```

用上面的程序求2的平方根，设定不同的EPS值，得到结果精确度也不同：
```
	EPS取值		输出结果
	1		1.5
	0.1		1.41667
	0.01		1.41422
	0.001		1.41421
	0.0001		1.41421
```

表面上看起来，当EPS取0.001和0.0001的时候，结果的精度已经没有区别，实际上，在这两种情况下程序中计算出来的最终的x值是不一样的，但因为cout语句只输出6位有效数字，所以导致输出结果看不出区别。想让cout语句输出更多有效数字，也是可以的，具体作法后面会学到。


用 do…while 语句实现循环结构
---------------------------

while语句先判断条件是否满足，然后再决定是否执行循环，这就导致循环可能一次也不会执行。如果希望循环至少要执行一次，就可以使用do…while语句。do…while的格式是：

```cpp
do {
		语句组
}while(表达式);

```

每执行一次循环后，都要判断“表达式”的值是否为真，如果真就继续循环，如果为假，就停止循环。下面的程序片段输出1到10000以内所有2的整数次幂：

```cpp
int n = 1;
do {
   cout << n << endl;
	   n <<= 1;   //左移1位相当于乘以2
}while( n < 10000);
```

用break语句跳出循环
---------------------------

break语句可以出现在循环体中(for、while、do…while循环均可)，其作用是跳出循环。在多重循环的情况下，break语句只能跳出直接包含它的那一重循环，通过下面的例题来说明：

例题:如果两个不同的正整数，他们的和是他们的积的因子，就称这两个数为兄弟数，小的称为弟数，大的称为兄数。先后输入正整数n和m(n < m) , 请在n至m这m-n+1个数中，找出一对兄弟数。如果找不到，就输出“No Solution.”。如果能找到，就找出和最小的那一对；如果有多对兄弟数和相同且都是最小，就找出弟数最小的那一对。


此题的思路就是枚举每一对不同的数，看看是不是兄弟数。用两个变量记录当前已经找到的最佳兄弟数，如果发现更佳的，就重新记录。解题程序如下：
```cpp
1.	#include <iostream>
2.	using namespace std;
3.	int main()
4.	{	
5.		int n,m;
6.		cin >> n >> m;
7.		int a = m + 1,b = m + 1;  //a,b用来记录已经找到的最佳兄弟数，a是弟数，b是兄数
8.		for( int i = n; i < m ; ++i )  { //取弟数，共m-n种取法
9.			 if( i > (a + b)/2 + 1) 
10.			 	 break;  // 跳出外重循环 
11.			 for( int j = i + 1; j <= m; ++j ) {  //取兄数
12.			 	  if( i + j > a + b )
13.			 	  	  break;  // 跳出内重循环 
14.			 	  if( i * j % (i + j) == 0 ) {  //发现兄弟数
15.				  	  if( i + j < a + b) {  //发现和更小的兄弟数
16.					  	  a = i;  b = j;   //更新已找到的最佳兄弟数
17.					  }
18.				  	  else if( i + j == a + b && i < a) { //发现和相同但弟数更小的兄弟数
19.					  	   a = i; b = j;  //更新已找到的最佳兄弟数
20.				      }
21.				  }
22.		     }	  
23.	    }
24.	    if( a == m + 1 )  //没找到兄弟数
25.	        cout << "No solution.";
26.	   	else
27.		    cout << a << "," << b ;
28.		return 0;
29.	}

```

第7行，变量a,b用来记录已经找到的最佳兄弟数，a是弟数，b是兄数。都初始化成m+1，是因为只要能找到兄弟数，它们的和就一定会小于初始的a+b值。

第9行，如果发现弟数i已经大于(a+b)/2 + 1, 由于后面尝试的兄数j是大于i的，所以i+j肯定大于a+b，因而此时继续往后尝试已经不可能找到比a、b更优的解了，因此就可以执行

第10行的break语句跳出外重循环，直接输出解或输出“No solution.”。

第12行，如果发现i+j的值已经大于当前的最佳兄弟数a、b的和，那么继续尝试更大的j就是没有意义的，所以可以通过执行第13行的break语句，跳出内重循环，回到外重循环继续
尝试下一个i，即下一个新的弟数。

这个程序说明在适当的时机跳出循环，可以避免无意义的尝试，加快程序执行速度。

这个程序，严格说来还不完美。首先，如果输入的n或m超过了int型变量的表示范围，那么程序肯定不能正确工作；其次，即便输入的n和m都没有超出int型变量的表示范围，在计算i*j、i+j的时候，正确的结果可能也会超过int型所能表示的范围(即溢出)，这也会导致程序运行结果不正确。好一点的解决办法是使用unsigned int类型，甚至long long 类型，如果要处理的整数更大，比如有数百位，那么只能用后面要讲的数组来存放整数了。

本书的程序，没有特殊说明，均假定不会发生溢出的现象。


continue语句
---------------
continue语句可以出现在循环体中(for、while、do…while循环均可)，其作用是立即结束本次循环，并回到循环开头判断是否要进行下一次循环。如下面的程序片段，会输出1到100内所有的偶数，奇数不输出。

```cpp
for( int i = 1;i <= 100 ;++i ) {
	if( i % 2 )
	 	  continue;  //导致不执行后面的语句，回到循环开头
	cout << i << endl;
}
```

和break语句类似，在多重循环的情况下，continue只对直接包含它的那重循环起作用。



