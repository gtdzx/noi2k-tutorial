Chap 1.4 逻辑表达式与条件分支
==================
作者：郭炜
时间：2015-07-14  

关系运算符
-----------------
关系运算符用于数值的大小比较。包括大于(“>”)、小于(“<”)、等于(“==”)、 大于等于(“>=”)、小于等于(“<=”)和不等于(“!= ”)六种。他们都是双目运算符。
关系运算符运算的结果是bool类型，值只有两种：true或false。false代表关系不成立，true代表关系成立。由于bool类型和整型可以自动互相转换，而true就是非0，false就是0，因此也可以认为关系运算符运算的结果是整型，0代表关系不成立，非0代表关系成立。
C++语言中，总是用0代表“假”，用非0代表“真”。比如表达式 3>5，其值就是0，代表该关系成不成立，即运算结果为假；表达式 3==3 ，其值就是非0，代表该关系成立，即运算结果为真。这个非0值，一般情况下就是1，但编程时最好不要依赖这一点，因为未必所有C++编译器都会把“真”值当成1。
请看下面的例子：
```cpp
1.	#include <iostream>
2.	using namespace std;
3.	int main()
4.	{
5.		int n1 = 4,  n2 = 5,  n3;
6.		n3 = ( n1 > n2 );   // n3 的值变为 0
7.		cout << n3 << ",";  // 输出 0,
8.		n3 = ( n1 < n2);    // n3 的值变为非0值
9.		cout << n3 << ",";	 // 输出 1,
10.		n3 = (n1 == 4);     // n3 的值变为非 0 值
11.		cout << n3 << ",";	 // 输出 1,
12.		n3 = (n1 != 4);     // n3 的值变为0
13.		cout << n3 << ",";	 // 输出 0,
14.		n3 = (n1 == 5);     // n3 的值变为0 
15.		cout << n3 ;	      // 输出 0,
16.		return 0;
17.	}
```
程序的输出结果是：
0,1,1,0,0

逻辑运算符和逻辑表达式
-----------------
逻辑运算符用于表达式的逻辑操作。包括与 (“&&”)、或(“||”)、非(“!”)三种。前二者是双目运算符，第三个是单目运算符。其运算规则如下：
当且仅当表达式exp1和表达式exp2的值都为真（或非0）时， exp1 && exp2 的值为真，其他情况， exp1 && exp2的值均为假。例如，如果 n = 4，那么n > 4 && n < 5的值就是假，n >= 2 && n < 5的值就是真。表达式 5 && 0 的值是假，4 && 1的值是真。
当且仅当表达式exp1和表达式exp2的值都为假（就是0）时，exp1 || exp2 的值为假，其他情况，exp1 || exp2的值均为真。例如，如果 n = 4，那么n > 4 || n < 5的值就是真，n <= 2 || n > 5的值就是假。表达式 5 || 0 的值是真。
如果表达式exp的值为真，那么 ! exp 的值就是假；如果exp的值为假，那么 ! exp 的值就是真。比如，表达式 ! (4 < 5 ) 的值就是假。!5 的值是真，!0 的值是假。
逻辑表达式由左到右计算。为提高程序的执行效率，对逻辑表达式的计算，在整个表达式的值已经能够断定的时候即会停止，这叫逻辑表达式的短路计算。例如：
exp1 && exp2 这个表达式，如果已经算出表达式exp1为假，那么整个表达式的值肯定为假，于是表达式exp2就不需要再计算了；而对于 exp1 || exp2，如果已经算出exp1为真，那么整个表达式必定为真，于是exp2也不必计算了。请看下面的程序：

```cpp
1.	#include <iostream>
2.	using namespace std;
3.	int main()
4.	{
5.	  	int a = 0,b = 1;
6.		bool n = a ++ && b ++ ;  // b++不被计算 
7.		cout << a << "," << b << endl; //输出 1,1 
8.		n =  a ++ && b ++ ;  // a++和b++都要计算 
9.		cout << a << "," << b << endl; //输出 2,2 
10.		n =  a ++ || b ++ ;	//b++不被计算 
11.		cout << a << "," << b << endl; //输出 3,2 
12.	    return 0;
13.	}
```
第6行的条件表达式 a ++ && b ++求值的过程就是先计算 a++的值，计算的结果会导致 a的值加1，但是a++这个表达式的值是a被加1以前的值，即0。由a++ 表达式的值为0即可断定 a ++ && b ++ 这个表达式的值一定为false,所以b++这个表达式就不必计算了，因此b的值没有被加1。所以，第7行会输出：1,1。

而在第8行计算条件表达式a ++ && b ++ 真假的时候，计算出a++为真（非0），并不能判断整个表达式的值，因此还要继续计算 b++的值，这导致b的值也增加，所以第9行会输出：2,2。

为什么第11行输出 “3,2”，请读者自行考虑。


分支语句(选择结构）
-----------------
程序是由一条条语句组成，执行时从前到后（或者说从上到下）顺序执行。但是，一个程序在执行过程中并不是每条语句都需要被执行到的。例如，写一个判断整数奇偶性的程序，要求输入一个整数，如果是奇数，就输出“It's odd.”，如果是偶数，就输出“It's even.”。显然，该程序里会有两条输出语句，一条输出“It's odd.”，一条输出“It's even.”。在程序的一次运行中，这两条语句不可能都被执行，而是要根据输入的整数，选一条来执行。这就要求程序设计语言提供根据某个条件来选择执行和不执行某些语句的机制，这个机制就叫选择结构，或叫分支语句。



用 if 语句实现选择结构
-----------------

在C++中，可以用if语句实现选择结构。if语句用法如下：

```cpp
if (表达式1) {
	语句组1
}
else if( 表达式2) {
	语句组2
}
else if( 表达式3) {
	语句组2
}
…….
else if(表达式n-1) {
	语句组n-1
}
else {
	语句组n
}
```

上述的“语句组”，由多条语句构成。中间的 else if可以写任意多组。每个表达式代表一个条件，每个语句组都是符合某个条件的情况下的一个执行分支。if语句的执行逻辑是：从上至下先后计算各个表达式是否为真，若不为真，则不执行该表达式后面的那对{ }中的语句组，继续计算下一个表达式；若碰到一个为真的表达式，则执行该表达式后面的那对{ }中的语句组，后面的表达式都不再计算，后面的语句组也都不再执行，接下去执行整个if语句后面的其他语句。如果所有的表达式都为假，则执行最后的else 对应的语句组n，然后再执行整个if语句后面的其他语句。表达式的值若为0，则等价于是假，若为非0，则等价于是真。
如果某个语句组只有一条语句，那么包裹它的那对“{}”可以省略。
根据实际需要，如果没有那么多条件以及选择分支，也可以一个else if都不写，也可以不写最后的else，而且也不是写了else if就一定要有else。比如:

```cpp
if( x > 0)
 	 cout << "x is positive" ;
```

上面这条if语句只在x>0时输出“x is positive”，如果x不大于0，则什么都不做。

现在我们可以写出上面提到的判断整数奇偶性的程序了:

```cpp
1.	#include <iostream>
2.	using namespace std;
3.	int main()
4.	{
5.	 	int n;
6.	 	cin >> n;
7.	 	if( n % 2 == 1) 
8.	  		 cout << "It's odd." ;   //当 n % 2 == 1 成立时会执行此语句
9.	 	else
10.	 		 cout << "It's even." ;  //当 n % 2 == 1 不成立时会执行此语句
11.	 	return 0;
12.	}
```

第7行的表达式“n % 2 == 1”就代表了一个条件，如果该表达式值为true，就说明n除以2的余数是1，那n就是奇数，那么会执行第8行；如果该表达式值为false,则不执行第8行，而执行else后面的第10行。
第7行也可以写成:

if( n % 2 )

因为如果n是奇数，则n%2的值就是非零值，同样能代表true。

有时，我们在if 语句的某个分支里面，还会要做进一步的选择，因此，C++中if语句是可以嵌套的，即在一条if语句的某个分支里，还可以再写if语句。在分支只有一条语句而省略了前后的“{}”的情况下，有时容易造成困惑，如下面的程序：

```cpp
1.	#include <iostream>
2.	using namespace std;
3.	int main()
4.	{
5.	 	int a;
6.	 	cin >> a;
7.		if( a > 0) 
8.				if ( a % 2 ) 
9.				   cout << "good";
10.		else 
11.				 cout << "bad";
12.		return 0;
13.	}
```
当输入-1时，该程序应该输出“bad”还是什么都不输出呢？
从程序的缩进格式看，似乎第10行的那个else应该是和第7行的那个if配对的，如果a<=0，则应该执行第11行，输出“bad”。但实际上，C++规定，在没有通过“{}”明确表明if和else的配对关系时，else是和离它最近的if相配对，所以本程序中的else实际上是和第8行的if配对的，即整个if语句实际上等效于：

```cpp
   if( a > 0)  {
		if ( a % 2 ) 
		   	cout << "good";
 	     else 
		   	cout << "bad";
    }
```

上面这个写法显然是不会引发困惑的。在a<=0的情况下，程序没有输出。
如果想让else和前面那个if配对，则应该这样写：
```cpp
	if( a > 0)  {
		if ( a % 2 ) 
		   cout << "good";
     }
 	else 
		cout << "bad";
```

此时如果a<=0，则程序输出“bad”。
在写嵌套if语句的时候，应当积极使用“{}”，以避免读程序者不小心看错了if和else的配对关系。


用 switch 语句实现选择结构
-----------------
程序经常要根据不同的情况执行不同的处理，如果情况很多，那么写出来的if语句就会包含大量的else if，比如：

```cpp
if( n % 5 == 0 ) {
	……
}
else if(n % 5 == 1 ) {
	……
}
else if( n % 5 == 2 ) {
	……
}
else if( n % 5 == 3 ) {
	……
}
else {
	……
}
……
```

上面的代码写起来有点麻烦，而且n%5这个表达式可能会被计算不止一次，也没有必要，不利于提高程序运行效率。为此，C++设计了switch语句，用于对付类似上面那样的需要很多个else if的情况。switch语句的基本格式是：

```cpp
switch(表达式) {
	case 常量表达式：
		语句组
		break;
	case 常量表达式：
		语句组
		break;
	……
	case 常量表达式n:
		语句组n;
		break;
	default:
		语句组n+1
}
```

 “switch”关键字右边的括号中的表达式，其值必须是整数类型的(char、unsigned char类型也可以)。“case”右边的那些表达式，必须是常量表达式，即不包含变量，且值是编译时就能确定，不会在运行时发生改变的表达式。switch语句的执行过程是：计算出括号中表达式的值，假设等于a, 然后找到第一个值和a相等的“常量表达式i”，执行其下面的语句组，一直执行到“break;”，整个switch语句就执行完毕，即便后面还有其他case分支的常量表达式值也等于a，那些分支也不会被执行。如果所有“case”右边的常量表达式都不等于a，则执行“default:”下面的语句组。
switch语句中的语句组即使包含不止一条语句，也可以不用“{}”括起来。switch语句也可以没有“default”部分，那样的话就相当于有一个什么都不做的“default”部分。



例题: 请写一个程序，接受一个整数作为输入，如果输入1，则输出“Monday”，输入2，则输出“Tuesday”……输入7,则输出“Sunday”，输入其他数，则输出“Illegal”。

```cpp
1.	#include <iostream>
2.	using namespace std;
3.	int main()
4.	{
5.	 	int n;
6.	 	cin >> n;
7.	 	switch(n) {
8.			case 1:
9.				cout << "Monday";
10.				break;
11.			case 2:
12.				cout << "Tuesday";			 
13.				break;
14.			case 3:
15.				cout << "Wednesday";	 
16.				break;
17.			case 4:
18.				cout << "Thursday";	 
19.				break;
20.			case 5:
21.				cout << "Friday";
22.	 		 	break;
23.			case 6:
24.				cout << "Saturday";
25.		 		break;
26.			case 7:
27.				cout << "Sunday";	
28.				break;
29.			default:
30.				cout << "Illegal";	
31.	  	}
32.	  	return 0;
33.	}

```


switch语句在进入某个case分支后，会一直执行到第一个碰到的“break;”，哪怕这个“break;”是在后面的case分支里面。果没有碰到“break;”，则会向下一直执行到switch语句末尾的“}”，包括“default:”部分的语句组也会被执行。初学者在使用switch语句的时候常常会忘了写“break;”，这会导致程序运行不正确。但有的时候，我们会需要多个case都执行相同的代码，那么就可以略去“break;”。例如下面的程序：
```cpp
1.	#include <iostream>
2.	using namespace std;
3.	int main()
4.	{
5.	 	int n;
6.	 	cin >> n;
7.	 	switch(n%6) {
8.			case 0:
9.				 cout << "case 0" << endl;
10.				 break;		
11.			case 1:
12.				 cout << "case 1" << endl;
13.			case 2:
14.			case 3:
15.				 cout << "case 2 or 3" << endl;
16.				 break;
17.			case 4:
18.				 cout << "case 4" << endl;
19.				 break;
20.			default:
21.				 cout << "default";	
22.	  	}
23.	  	return 0;
24.	}
```

上面的程序，如果输入1,则会输出：

```
case 1
case 2 or 3
```

因为进入case 1分支，执行完第12行后，没有碰到“break;”，于是程序继续向下执行了第15行和第16行，第16行是“break;”，到此switch语句执行完毕。
如果输入2或者3，则都会执行第15行，然后执行第16行的“break;”时结束整个switch语句的执行。此种情况下程序输出：

```case 2 or 3```

