Chap 1.2
==============================
作者：李文新、gtdzx
时间：2015-2-1

变量的定义
--------------
###标识符
首先我们来了解一下**标识符**这个概念。标识符是程序员对程序中的各个元素加以命名时使用的命名记号。这些元素可能是变量、函数、数据类型等。  
例如在上一节我们见到的```main```、```scanf```、```int```、```return```等都是标识符。  
需要注意的是：  
- C语言中合法的标识符是由大小写字母、下划线和数字组成的字符序列，并且第一个字符不能是数字。
- C语言中的标识符是大小写敏感的，a和A是不同的标识符。  

合法的标识符举例: ```a```  ```Aa``` ```c1``` ```x23``` ```y2a``` ```_``` ```_pku_```  
非法的标识符举例: ```1```  ```123``` ```0Ac``` ```a!``` ```@W```  ```-X-```  

###变量的定义
变量的定义包含**数据类型**、**变量名**、**初值**三个部分，其中初值是可选的。例如：
```cpp
int sum = 0;
```
```int``` 是数据类型，表明变量是一个整数类型的变量（简称“整型”）。  
```sum``` 是变量的名字，它必须是一个合法的标识符。  
```=0``` 是把sum变量的初始值设为0。在变量定义时设初始值是好的编程习惯。  

我们可以在一条语句中定义多个数据类型相同的变量。例如：
```cpp
int sum = 0, diff, x = 1;
```

变量与内存
--------------
###内存的抽象
一旦程序开始运行，程序中定义的变量就会存储在内存中。每个变量根据数据类型不同，占用不同大小的内存。  
计算机的内存可以想像成一条长长的带状存储空间。  
![Fig1-2-1](Fig1-2-1.png)  
带中的每一行代表一个基本的存储单元——字节(Byte)。  
每个字节包含8个二进制位——比特(bit)，其中每个比特可以存储0或者1。  
每个字节都被从0开始依次编号，这个编号叫做“地址”。习惯上我们会用一个16进制数来描述一个地址，例如**3FFD00**指的是内存中第3600128个字节。

除了Byte，我们常用的存储单位还有KB、MB(兆)、GB(G)、TB(T)、PB(P)等。它们之间的换算关系如下表所示。  
1KB = 1024Byte  
1MB = 1024KB  
1GB = 1024MB  
1TB = 1024GB  
1PB = 1024TB  
我们可以看出字节相对于现在的计算机内存来说是一个非常小的单位。如果我们的计算机内存是4G大小的话，它可以存储大约40亿个字节的数据。
###变量的存储
当程序运行时，程序中定义的变量会被存储在内存中。例如
```cpp
int sum = 0;
```
操作系统会找到一段没有被使用的内存，把```0```存放到这段内存中，并且把这段内存的初始地址与变量名```sum```关联起来。这段内存的大小与变量的数据类型有关。
###不同数据类型的内存占用
|数据类型|内存占用|
|:------:|:------:|
|int     | 4Byte  |
|short   | 2Byte  |
|long    | 8Byte  |
|long long|8Byte  |
|char    | 1Byte  |
|float   | 4Byte  |
|double  | 8Byte  |
|bool    | 1Byte  |
其中```int```,```short```,```long```,```long long```都是整数类型，它们占用的内存大小不同使得它们能表示的整数范围有差别。  ```float```和```double```都是浮点数类型，它们占用的内存大小不同使得它们能表示的浮点数范围有差别。我们会在下一节详细说明。  

###sizeof函数
C语言中提供了一个非常方便的函数```sizeof```，它可以计算一个数据类型或者变量占用了多少个字节。用法如下：
````cpp
#include<stdio.h>
int main()
{
        int a;
        short b;
        long c;
        long long d;
        char e;
        float f;
        double g;
        bool h;
        printf("%d %d\n", sizeof(int), sizeof(a));
        printf("%d %d\n", sizeof(short), sizeof(b));
        printf("%d %d\n", sizeof(long), sizeof(c));
        printf("%d %d\n", sizeof(long long), sizeof(d));
        printf("%d %d\n", sizeof(char), sizeof(e));
        printf("%d %d\n", sizeof(float), sizeof(f));
        printf("%d %d\n", sizeof(double), sizeof(g));
        printf("%d %d\n", sizeof(bool), sizeof(h));
        return 0;
}
```
输出是：
```
4 4
2 2
8 8
8 8
1 1
4 4
8 8
1 1
```

变量的二进制表示
----------------
###整型的二进制表示
整型分为无符号整型(```unsighed int```)和有符号整型(```signed int```, 我们平时常用的```int```其实就是有符号整型)两种。它们都占用4Byte的内存，32个bit(二进制位)。每一个bit都可能有0和1两种状态，32bit一共有2^32种不同的状态，所以可以表示2^32个不同的整数。但是```singedn int```和```unsigned int```表示的具体范围略有不同。  
```unsighed int```表示的整数范围是0 ~ 2^32-1，也即0 ~ 4294967295。  
```signed int```和```int```表示的范围是-2^31 ~ 2^31-1，也即-2147483648 ~ 2147483647。

对于```unsigned int```，32个bit的状态与对应的整数关系如下表。  

|32bit    |整数|
|:-------:|:--------:|
|1111...11|4294967295|
|1111...10|4294967294|
|    ...  |...       |
|1000...00|2147483648|
|...      |...       |
|0000...01|1         |
|0000...00|0         |

对于```signed int```和```int```，32个bit的状态与对应的整数关系如下表。  

|32bit    |整数|
|:-------:|:--------:|
|111...11|-1        |
|111...10|-2        |
|    ...  |...       |
|1000...00|-2147483648|
|0111...11|2147483647|
|0111...10|2147483646|
|...      |...       |
|0000...01|1         |
|0000...00|0         |
这种二进制与(有符号)十进制直接的对应表示关系叫做**补码表示法**。

###字符类型的二进制表示
首先我们来认识一下**ASCII码**。ASCII码是一套字符编码，作用是将字符同整数对应起来，具体见下图：  
![](http://computing.or.kr/wp-content/uploads/2015/04/ASCII-Table.png)  
例如：  
'0'~'9'对应的ASCII码是48~57  
'A'~'Z'对应的ASCII码是65~90   
'a'~'z'对应的ASCII码是97~122   
char类型实际存储的是字符对应的ASCII码，**是一个整数**。  

###浮点类型的二进制表示
浮点类型的二进制表示遵循[IEEE二进制浮点数算术标准](http://zh.wikipedia.org/wiki/IEEE_754)，即IEEE754标准。  
这个标准中详细规定了一个浮点数是如何用二进制表示的。个中细节比较复杂，这里就不介绍了。有兴趣的同学可以点击上文的链接进一步了解。  
值得一提的是浮点类型是有误差的。我们知道实数域中有无穷多个实数，但我们用32bit的float只能表示2^32个不同的实数。在两个相邻的能表示的实数之间，有无数个实数是float无法表示的，于是就产生了误差。64bit的double可以表示更多的实数，所以精度比float高，误差比float小，但仍然不能避免误差。  

变量的赋值与转换
---------------
###变量的赋值
变量，顾名思义，它里面的数值是可以变化的。给变量指定一个新的值的过程称为变量的赋值，通过赋值语句完成。
赋值语句的形式是：  
```变量名 = 常量;  ```  
或者  
```变量名 = 变量名;```

其中常量也分为不同的数据类型。  
整型：```123```， ```-123```   
浮点类型：```1.23```, ```-1.23```  
字符常量：单引括起来的一个一个字符 ```'a'``` ```'A'``` ```'?'``` ```' '``` ```'\n'```  
字符串常量: 双引号括起来的一个或多个字符```"Hello World\n"```

合法的赋值：
```cpp
int sum = 0, x;
char ch;
float height;
sum = 1;
ch = 'a';
height = 1.71;
x = sum;
```
不合法的赋值：
```cpp
int sum = 0, x;
char ch;
float height;
1 = sum;
ch = 'ab';
ch = "ab";
```
###变量的赋值与溢出
变量中能保存的数值是有一定范围的，例如int类型的保存的整数范围在-2^31~2^31-1之间。当我们试图把一个范围之外的数值赋值给int变量时，就会发生**溢出**。溢出发生时，变量中的数值会被"调整"到范围之内。  
例如如下程序
```cpp
#include<stdio.h>
int main()
{
    int vint = 2147483647;
    printf("%d\n", vint);
    vint = vint + 1;
    printf("%d\n", vint);
    return 0;
}
```
输出是:
```
2147483647
-2147483648
```
###整型与字符类型互相转换
如下程序所示，vchar是一个字符类型变量，vint是一个整型变量。```vint = vchar;``` 实际是把vchar的ASCII码赋值给vint，```vchar=vint;``` 实际是把vchar改成ASCII码是vint的字符。
```cpp
#include<stdio.h>
int main()
{
    int vint = 0;
    char vchar = 'A';
    vint = vchar;
    printf("%d\n", vint);
    vchar = vint + 1;
    printf("%c\n", vchar);
    return 0;
}```
输出是：
```
65
B
```
###整型与浮点数类型互相转换
如下程序所示，vfloat是一个浮点数类型变量，vint是一个整型变量。```vint = vfloat;```是把vfloat向0取整的值赋给vint，```vfloat=vint;```是把vint当成一个浮点数赋给vfloat。
```cpp
#include<stdio.h>
int main()
{
    int vint = 0;
    float vfloat = 123.3;
    vint = vfloat;
    printf("%d\n", vint);
    vfloat = -123.3
    vint = vfloat;
    printf("%d\n", vint);
    return 0;
```
输出是：
```
123
-123
```
