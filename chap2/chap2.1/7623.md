# 信息
题目：《五户共井问题》  
链接：http://noi.openjudge.cn/ch0201/7623/

作者：源暗

时间：2015-04-28
  
# 描述

有A, B, C, D, E五家人共用一口井，已知井深不超过k米。A, B, C, D, E的绳长各不相同，而且厘米表示的绳长一定是整数。   
从井口放下绳索正好达到水面时：   
(a)需要A家的绳n1条接上B家的绳1条    
(b)需要B家的绳n2条接上C家的绳1条   
(c)需要C家的绳n3条接上D家的绳1条   
(d)需要D家的绳n4条接上E家的绳1条   
(e)需要E家的绳n5条接上A家的绳1条   
问井深和各家绳长。

# 提示

首先，我们需要按照题目的输入格式，从标准输入中读取k, n1, n2, n3, n4, n5。

```cpp
int k, n1, n2, n3, n4, n5;
scanf("%d%d%d%d%d%d", &k, &n1, &n2, &n3, &n4, &n5);
```

然后，根据枚举法的思想，一种方法是依次枚举每家人的绳子的长度，由于绳子的长度一定是正整数，而且长度小于等于k*100（不然井的深度一定大于k），这样的方法是可以计算出结果的。

但是，由于k最大可能是20，如果枚举5家人的绳子长度的话，就会是一个5层循环，每层循环有2000种可能的枚举，也就是要进行2000的5次方次计算，这样是非常慢的，在题目要求的时间范围内很难计算出来。

所以需要少进行一些枚举，不难发现，在**枚举了A家的绳子长度A和B家的绳子长度B之后**，我们就可以知道井的深度H=A*n1+B（根据题目中的a式）。

同理，根据题目中的b式，我们可以知道H = B * n2 + C，在这个式子里，H、B和n2都是已知量，于是我们可以通过变形这个式子为C = H - B * n2来计算出C的值。

以此类推，利用c式的变形D = H - C * n3，d式的变形E = H - D * n4可以分别计算出D和E来。

也就是说我们只需要枚举A和B的值，就可以利用数学方法计算出H、C、D、E的值来。

```cpp
int main() {
	int k, n1, n2, n3, n4, n5;
	scanf("%d%d%d%d%d%d", &k, &n1, &n2, &n3, &n4, &n5);
	int A, B, C, D, E, H;
	for (A = 1; A <= k * 100; A ++)
		for (B = 1; B <= k * 100; B ++) {
			// 得到H、C、D、E的值
			H = A * n1 + B;
			C = H - B * n2;
			D = H - C * n3;
			E = H - D * n4;
		}
	return 0;
}
```

相比于最开始的枚举5个变量的值，现在只需要枚举2个变量就可以做到相同的效果。

于是接下来要做的便是**检验这些枚举的量是否满足题目的要求**，不难发现，由于我们是利用了原题中的a,b,c,d式得到的这些数值，所以这些等式是肯定可以得到满足的。唯一不能确保满足的就是e式，所以需要进行检查，如果不能满足的话就需要淘汰掉当前枚举的这种方案。

当然更加要注意的是，C、D、E的值都需要是正数，A、B、C、D、E互不相同，H不能超过k*100等条件。

```cpp
int main() {
	int k, n1, n2, n3, n4, n5;
	scanf("%d%d%d%d%d%d", &k, &n1, &n2, &n3, &n4, &n5);
	int A, B, C, D, E, H;
	for (A = 1; A <= k * 100; A ++)
		for (B = 1; B <= k * 100; B ++) {
			// 得到H、C、D、E的值
			H = A * n1 + B;
			C = H - B * n2;
			D = H - C * n3;
			E = H - D * n4;
			// 检查e式是否满足
			if (E * n5 + A != H) continue;
			// 检查C、D、E是否为负数
			if (C <= 0 || D <= 0 || E <= 0) continue;
			// 检查A、B、C、D、E是否有相等的情况
			if (A == B || A == C || A == D || A == E ||
				B == C || B == D || B == E ||
				C == D || C == E || 
				D == E)
				continue;
			// 检查H是否超过了k * 100
			if (H > k * 100) continue;
		}
	return 0;
}
```

最后，我们来看题目要求的输出格式：  

	如果找到了可行解，就输出6个整数，用空格分开，分别代表井的深度和A, B, C, D, E的绳长（单位都是厘米）。  
	如果有多组可行解，输出井的深度最小的那组解。  
	如果不存在可行解，就输出一行：  
	not found  

对于这样的要求，我们可以使用变量ANSH, ANSA, ANSB, ANSC, ANSD, ANSE，来记录当前ANSH最小的那一组解，并且ANSH的初始值设置为10000，然后每当枚举出一组合法方案的时候，就用H同ANSH进行比较，如果H小于ANSH的话，就将最优答案替换为当前答案。

这样如果在枚举了所有方案之后，如果ANSH仍然是10000的话，就说明这组输入无解，否则变量ANSH, ANSA, ANSB, ANSC, ANSD, ANSE存储的就是当前最优的一组解。

```cpp
#include <stdio.h>

int main() {
	int k, n1, n2, n3, n4, n5;
	scanf("%d%d%d%d%d%d", &k, &n1, &n2, &n3, &n4, &n5);
	int A, B, C, D, E, H;
	int ANSH = 10000, ANSA, ANSB, ANSC, ANSD, ANSE;
	for (A = 1; A <= k * 100; A ++)
		for (B = 1; B <= k * 100; B ++) {
			// 得到H、C、D、E的值
			H = A * n1 + B;
			C = H - B * n2;
			D = H - C * n3;
			E = H - D * n4;
			// 检查e式是否满足
			if (E * n5 + A != H) continue;
			// 检查C、D、E是否为负数
			if (C <= 0 || D <= 0 || E <= 0) continue;
			// 检查A、B、C、D、E是否有相等的情况
			if (A == B || A == C || A == D || A == E ||
				B == C || B == D || B == E ||
				C == D || C == E || 
				D == E)
				continue;
			// 检查H是否超过了k * 100
			if (H > k * 100) continue;

			// 同当前最优解进行比较
			if (H < ANSH) {
				ANSH = H;
				ANSA = A; ANSB = B; ANSC = C; ANSD = D; ANSE = E;
			}
		}
	if (ANSH == 10000) {
		printf("not found");
	}
	else{
		printf("%d %d %d %d %d %d", ANSH, ANSA, ANSB, ANSC, ANSD, ANSE);
	}
	return 0;
}
```

这样的程序最后就可以通过啦！