Chap 2.2 递归和自调用函数
==================
作者：源暗

时间：2015-05-18

阶乘
---

阶乘是一个非常有趣的数学概念，用一个简单的式子表示的话，就是

$$N!=1*2*3*4*...*(N-1)*N$$

但是这样的定义有点冗杂，省略号也有些不严谨，特别对于N只有1、2的时候，很难进行很好的解释。

所以我们不妨尝试用另一种方式来定义阶乘：

- 当$$N>0$$时，$$N!=(N-1)!*N$$ 
- 当$$N=0$$时，$$N!=1$$

这样一来，只要N是一个非负的整数，我们都可以用这样的定义很好的进行表示。

于是按照这样的定义，我们可以写一个小程序来计算$$N!$$

```cpp
#include <stdio.h>

int jiecheng(int n) {
	if (n > 0) return jiecheng(n - 1) * n;
	if (n == 0) return 1;
}

int main() {
	int n;
	scanf("%d", &n);
	if (n < 0) {
	    printf("错误的输入\n");
	}
	else {
	    printf("%d\n", jiecheng(n));
	}
}
```

兔子的故事
--------------

有一种特殊的兔子，从出生开始，花一个月的时间正好长大，一对长大后的兔子每隔一个月可以生出一对小兔子来，如果在一片从来没有出现过兔子的大草原上，放生了一对刚出生的小兔子，那么N个月后，草原上会有多少对兔子呢？

对于这样一个略为复杂的问题，我们不妨手动模拟一下：放生0个月后，也就是刚放生的时候，草原上有1对刚出生的小兔子，0对长大的兔子，总共1对兔子。

放生1个月后，1对小兔子长大了，于是草原上有0对刚出生的小兔子，1对长大的兔子，总共1对兔子。

放生2个月后，1对长大的兔子生下了1对小兔子，于是草原上有1对刚出生的小兔子，1对长大的兔子，总共2对兔子。

放生3个月后，1对小兔子长大了，1对长大的兔子生下了1对小兔子，于是草原上有1对刚出生的小兔子，2对长大的兔子，总共3对兔子。

以此类推，放生4个月后，草原上有2对刚出生的小兔子，3对长大的兔子，总共5对兔子。

…………

如果将每个月的兔子数列成一排的话，会是这样的：$$1, 1, 2, 3, 5, 8, 13, 21, ...$$

不难发现，**每个数都是他前两个数的和！**（证明也是很简单的哟~）

对于这样的性质，我们不妨使用类似阶乘的定义方式，用Rabbits(N)表示放生N个月后的兔子总数，给出漂亮的式子：

- 当$$N>1$$时，$$Rabbits(N)=Rabbits(N-1)+Rabbits(N-2)$$
- 初值：$$Rabbits(0)=1,Rabbits(1)=1$$

这个定义和阶乘非常的类似，于是我们也可以仿照阶乘的程序，写一个用以计算兔子数量的小程序：

```cpp
#include <stdio.h>

int Rabbits(int n) {
	if (n > 1) return Rabbits(n - 1) + Rabbits(n - 2);
	if (n == 0) return 1;
	if (n == 1) return 1;
}

int main() {
	int n;
	scanf("%d", &n);
	if (n < 0) {
	    printf("错误的输入\n");
	}
	else {
	    printf("%d\n", Rabbits(n));
	}
}
```

而这个数列，实际上就是著名的**斐波那契数列**。

什么是递归？
---
对于阶乘和斐波那契数列来说，他们的定义方式都是类似的：**利用自身来定义自身，并通过将问题规模缩小来解决问题**，也可以用“自调用函数”来形容这种定义方式。

这种定义方式是简洁而充满美感的，只需要将定义简单的转换成代码，就可以快速的计算需要的值。

在计算机的领域中，我们称这样的定义方式为——**递归**

递归需要两个条件：

1.存在一个所谓的**“递归式”**，能够将一个问题的解决转化为若干个规模变小的问题。

2.存在一些所谓的**“终点”**，能够让问题的规模缩小在某个点停止下来。

这就是递归！

---

那么问题来了，第N个月草原上到底有多少对兔子呢？

似乎很难给出一个具体的关于N的代数式来。

但是我们不妨，用``Number(N)``表示，第N个月草原上的兔子数量，来看看``Number(N)``满足怎么样的性质。

``Number(N)``代表着第N个月草原上的兔子数量，其来源有2种，一种是第N-1个月草原上本来就有的兔子数量，即``Number(N-1)``。

而第二种，则是**``在第N个月的开始生下的小兔子``**，这个数量，会和在**``第N-1个月的开始已经成为了大兔子的兔子数量``**有关，而在第N-1个月的开始已经成为了大兔子的兔子数量，其实就是在**``第N-2个月已经出生了的兔子的数量``**，即``Number(N-2)``。

于是我们可以得到一个非常漂亮的式子**``Number(N)=Number(N-1)+Number(N-2)``**。

不难发现，虽然``Number(N)``不能够使用一个简单的如只包含N的多项式来进行表示，却可以简单的表示成为一个由它自己构成的式子。

这样自己的定义中包含自己的函数（如Number(N)），就被称为自调用函数。

而这样的定义方式，也就被称为递归定义。

递归定义在数学中十分常见，如上例中的“斐波那契数列”和阶乘的定义``N! = (N-1)! * N``，就是最为熟悉的两个。

但是需要注意的是，与自调用函数不同，**递归是需要有“尽头”的**，如``Number(1)=1, Number(2)=1``，``0!=1``这种，就是递归的边界值，**他们的存在，使得递归不会无休止的重复下去，保证了定义出的值是可以计算出来的**。

如何解决递归定义的问题？
-------

不妨来看一个有趣的问题——汉诺塔。

> 汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

> 如果移动一个圆盘需要花费1秒时间，那么至少要多久婆罗门才能完成这项任务呢？

不妨设黄金圆盘的数量为N，而移动完这N个圆盘的时间为Time(N)，那么我们要求的答案便是Time(64)。

那么应该如何移动才能花费时间最少呢？我们不妨从最大的圆盘开始考虑，如果给三根柱子分别编号为A、B、C，最开始所有圆盘都在柱子A上，而最后希望能够将所有圆盘移动到柱子C上。

那么**对于最大的圆盘来说，如果它想要移动到柱子C上，就必须保证其他所有的圆盘都在柱子B上**，它才能够顺利的从柱子A移动到柱子C。

既然最大的圆盘移动到了C，那么它就再也不需要移动了，于是只需要考虑，如何将剩下的N-1个柱子从柱子B移动到柱子C上。

即**``Time(N)=将N-1个圆盘从柱子A移动到柱子B的时间+1+将N-1个圆盘从柱子B移动到柱子C的时间``**。

定睛一看，便会发现，其实这个式子就是**``Time(N)=Time(N-1)+1+Time(N-1)=2*Time(N-1)+1``**。

加上Time(1)=1的边界值，不难发现，所谓的汉诺塔问题的解，其实也是递归定义的。

那么对于这个问题来说，似乎还是不知道如何解？

不妨来对这个式子进行一些变化，首先将两边同时+1，可以得到``Time(N)+1=2*Time(N-1)+2``，即``Time(N)+1=2*(Time(N-1)+1)``。

如果令``f(N)=Time(N)+1``的话，我们会有``f(N)=2*f(N-1)``，再加上``f(1)=Time(1)+1=2``，我们不难发现``f(N)=2^N``，从而再利用``f(N)=Time(N)+1``，便可以知道``Time(N)=2^N-1``。

于是利用了一些数学手段，我们便将汉诺塔问题，从递归定义中求解了出来，得到了一个非常简洁的式子，这便是解决递归问题的第一种方法，数学手段，利用递归定义式的种种数学特性，来进行求解。