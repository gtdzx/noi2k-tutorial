# 信息
题目：《全排列》  
链接：http://noi.openjudge.cn/ch0202/1750/

作者：源暗

时间：2015-07-06
  
# 描述

给定一个由不同的小写字母组成的字符串，输出这个字符串的所有全排列。

我们假设对于小写字母有'a' < 'b' < ... < 'y' < 'z'，而且给定的字符串中的字母已经按照从小到大的顺序排列。

# 提示

首先，我们需要对于这个问题进行分析，以给出其递归定义式。

问题要求的是一个字符串的所有全排列，也就是说对于一个字符串s，按字典序从小到大的顺序输出其所有的全排列，我们不妨称这个过程为work(s).

那么对于work(s)来说，它可以怎么样的**划分成小规模的任务呢**？

不妨这样想，对于work(s)输出的所有全排列来说，它们的第一个字符一定是按照从小到大的顺序进行的，而如果设定s的长度为n的话，可以这样表示work(s).

- 输出以s[0]开头的$$(n-1)!$$个全排列
- 输出以s[1]开头的$$(n-1)!$$个全排列

问题要求的是正整数a的因式分解数，不妨设为$$count(a)$$，那么该如何将$$count(a)$$转化为一个规模较小的问题呢？一个很明显的思路是，**枚举其第一个因子的大小**！

不妨设a是2的倍数，那么根据$$a = 2 * (a / 2$$，我们可以将$$a/2$$的每一种因式分解的最前面加上“$$2 *$$”，就可以得到一种a的因式分解。

于是按照题目的描述，我们很容易给出这样的一个递归式：

- 当$$i$$不为整数时，$$count(i)=0$$
- 当$$i=1$$时，$$count(i)=1$$
- 当$$i>1$$时，$$count(i)=count({i \over 2})+count({i \over 3})+...+count({i \over i})$$

但是这个式子显然是存在问题的，因为它没有考虑一个条件，即“$$1 < a_1 <= a_2 <= a_3 <= ... <= a_n$$”，在实际计算中，会多计算出很多不符合题目要求的因式分解，为了解决这个问题，我们不得不将问题复杂化，添加一个参数用来确保因子从小到大排列。

不妨令$$count(i, j)$$表示“**正整数$$i$$的所有因式分解中，满足条件‘最小的因子不小于$$j$$’的数量**”，不难发现我们最后的答案便是$$count(a, 2)$$，而其递归定义式也变成了：

- 当$$i$$不为整数时，$$count(i, j)=0$$
- 当$$i=1$$时，$$count(i, j)=1$$
- 当$$i>1$$时，$$count(i, j)=count({i \over j}, j)+count({i \over j+1}, j + 1)+...+count({i \over i}, i)$$

由于将当前使用的因子“告诉”了之后计算，这样的一个式子便可以避免之后使用的因子比当前使用的因子小的情况，很好的符合了题目的要求，于是，我们可以按照递归问题的一般解法和这个递归定义式来编写程序：

```cpp
#include <stdio.h>

// 递归计算count(i, j)
int count(int i, int j) {
	if (i == 1) return 1; // 定义式第2条
	int s = 0, k;
	for (k = j; k <= i; k++) // 从最小的可能j开始枚举到最大的可能i
		if (i % k == 0) // 定义式第1条，要求i/k一定为整数
			s += count(i / k, k); // 取所有方案的和
	return s;
}

int main() {
    // 读取数据组数
	int n;
	scanf("%d", &n);
	while (n --) {
	    // 对于每组数据，读取a
		int a;
		scanf("%d", &a);
		int ans;
		// 递归计算答案并输出
		ans = count(a, 2);
		printf("%d\n", ans);
	}
	return 0;
}
```

这样的一个问题便可以很好的被解决了~