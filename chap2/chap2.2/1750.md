# 信息
题目：《全排列》  
链接：http://noi.openjudge.cn/ch0202/1750/

作者：源暗

时间：2015-07-06
  
# 描述

给定一个由不同的小写字母组成的字符串，输出这个字符串的所有全排列。

我们假设对于小写字母有'a' < 'b' < ... < 'y' < 'z'，而且给定的字符串中的字母已经按照从小到大的顺序排列。

# 提示

首先，我们需要对于这个问题进行分析，以给出其递归定义式。

问题要求的是一个字符串的所有全排列，也就是说对于一个字符串s，按字典序从小到大的顺序输出其所有的全排列，我们不妨称这个过程为work(s).

那么对于任意的一个字符串t来说，work(t)怎样**划分成小规模的任务呢**？

不妨这样想，对于work(t)输出的所有全排列来说，它们的第一个字符一定是按照从小到大的顺序进行的，而如果设定t的长度为l的话，可以这样表示work(t).

- 输出以t[0]开头的(l-1)!个全排列
- 输出以t[1]开头的(l-1)!个全排列
- 输出以t[2]开头的(l-1)!个全排列
- ...
- 输出以t[l]开头的(l-1)!个全排列

这样就可以通过调用work(s)，将总共l!个全排列全部处理完成。

并且，对于以t[0]开头的(l-1)!个全排列来说，如果我们不考虑这些字符串的第一个字符（一定是t[0]），那么剩下的字符串便是t[1]..s[n]的全排列，例如对于样例'abc'来说，它的前2个全排列'abc'和'acb'在去掉第一个字符'a'之后便是'bc'的全排列。

以此类推，如果用t'[i]表示t去掉第i个字符之后的字符串的话，我们可以这样表示work(t)

- work(t'[0])
- work(t'[1])
- ...
- work(t'[l])

但是这样在进行到了work('')（即t为空字符串）的时候，我们却不知道该如何输出答案，于是我们需要多保留一个信息，即在之前的过程中已经确定了的前缀pre，也就是说对于一个字符串t，输出其所有全排列，并且都加上一个前缀pre。

那么work(pre, t)可以表示为
```c
if (t > 0) {
	work(pre + t[0], t'[0])
	work(pre + t[1], t'[1])
	...
	work(pre + t[l], t'[l])
}
else {
	输出pre
}
```
而我们最终的答案便可以通过work('', s)来得到。

至此，对这个问题的分析基本完成，我们可以通过编写上述过程的代码来得到这个问题的答案。

在具体的代码编写过程中，可以采取一些特殊的优化，来避免字符串操作。

由于t'[i]实际上就是t去掉第i个字符得到的字符串，对于一个子问题来说，它的s永远比它的父问题的s少一个字符，那么我们不妨维护一个“当前子问题中可以使用的字符”，每当从父问题递归进入子问题时，就将对应的字符置为不可用，而在子问题处理完之后，将对应的字符重新置为可用。

```cpp
#include <stdio.h>
#include <string.h>

int l, use[10];
char pre[10], s[10];

// 此处的i表示当前pre的长度，pre[0..i]即为pre字符串，而t则可以表示为s字符串中所有use=0的字符组成的字符串
void work(int i) {
	// 如果pre的长度为n，说明s已经为''了，可以将pre输出
	if (i == l) {
		printf("%s\n", pre);
	}

	// 在可用的字符中，枚举全排列的第一个字符
	int j;
	for (j = 0; j < l; j++) if (!use[j]) {
		// 将j从t中去除
		use[j] = 1;
		// 记录前缀
		pre[i] = s[j];
		// 进入子任务进行计算
		work(i + 1);
		// 将j加入到t中
		use[j] = 0;
	}
}

int main() {
	// 输入s
	scanf("%s", s);

	// 计算s的长度l
	l = strlen(s);

	// 使用use数组表示s中的哪些字符是可用的，0表示可用，1表示不可用
	int i;
	for (i = 0; i < l; i++) use[i] = 0;

	// 计算结果
	work(0);
}
```