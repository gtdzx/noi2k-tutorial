# 信息
题目：《分解因数》  
链接：http://noi.openjudge.cn/ch0202/1751/

作者：源暗

时间：2015-06-22
  
# 描述

给出一个正整数a，要求分解成若干个正整数的乘积，即 $$a=a_1 * a_2 * a_3 * ... * a_n$$，并且 $$1 < a_1 <= a_2 <= a_3 <= ... <= a_n$$，问这样的分解的种数有多少。注意到$$a = a$$也是一种分解。

# 提示

首先，我们需要对于这个问题进行分析，以给出其递归定义式。

问题要求的是正整数a的因式分解数，不妨设为$$count(a)$$，那么该如何将$$count(a)$$转化为一个规模较小的问题呢？一个很明显的思路是，**枚举其第一个因子的大小**！

不妨设a是2的倍数，那么根据$$a = 2 * (a / 2)$$，我们可以将$$a/2$$的每一种因式分解的最前面加上“$$2 *$$”，就可以得到一种a的因式分解。

于是按照题目的描述，我们很容易给出这样的一个递归式：

- 当$$i$$不为整数时，$$count(i)=0$$
- 当$$i=1$$时，$$count(i)=1$$
- 当$$i>1$$时，$$count(i)=count({i \over 2})+count({i \over 3})+...+count({i \over i})$$

但是这个式子显然是存在问题的，因为它没有考虑一个条件，即“$$1 < a_1 <= a_2 <= a_3 <= ... <= a_n$$”，在实际计算中，会多计算出很多不符合题目要求的因式分解，为了解决这个问题，我们不得不将问题复杂化，添加一个参数用来确保因子从小到大排列。

不妨令$$count(i, j)$$表示“**正整数$$i$$的所有因式分解中，满足条件‘最小的因子不小于$$j$$’的数量**”，不难发现我们最后的答案便是$$count(a, 2)$$，而其递归定义式也变成了：

- 当$$i$$不为整数时，$$count(i, j)=0$$
- 当$$i=1$$时，$$count(i, j)=1$$
- 当$$i>1$$时，$$count(i, j)=count({i \over j}, j)+count({i \over j+1}, j + 1)+...+count({i \over i}, i)$$

由于将当前使用的因子“告诉”了之后计算，这样的一个式子便可以避免之后使用的因子比当前使用的因子小的情况，很好的符合了题目的要求，于是，我们可以按照递归问题的一般解法和这个递归定义式来编写程序：

```cpp
#include <stdio.h>

// 递归计算count(i, j)
int count(int i, int j) {
	if (i == 1) return 1; // 定义式第2条
	int s = 0, k;
	for (k = j; k <= i; k++) // 从最小的可能j开始枚举到最大的可能i
		if (i % k == 0) // 定义式第1条，要求i/k一定为整数
			s += count(i / k, k); // 取所有方案的和
	return s;
}

int main() {
    // 读取数据组数
	int n;
	scanf("%d", &n);
	while (n --) {
	    // 对于每组数据，读取a
		int a;
		scanf("%d", &a);
		int ans;
		// 递归计算答案并输出
		ans = count(a, 2);
		printf("%d\n", ans);
	}
	return 0;
}
```

这样的一个问题便可以很好的被解决了~